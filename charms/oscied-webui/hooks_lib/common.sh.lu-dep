#!/usr/bin/env bash

#**************************************************************************************************#
#              OPEN-SOURCE CLOUD INFRASTRUCTURE FOR ENCODING AND DISTRIBUTION : WEB UI
#
#  Authors   : David Fischer
#  Contact   : david.fischer.ch@gmail.com / david.fischer@hesge.ch
#  Project   : OSCIED (OS Cloud Infrastructure for Encoding and Distribution)
#  Copyright : 2012 OSCIED Team. All rights reserved.
#**************************************************************************************************#
#
# This file is part of EBU/UER OSCIED Project.
#
# This project is free software: you can redistribute it and/or modify it under the terms of the
# GNU General Public License as published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This project is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this project.
# If not, see <http://www.gnu.org/licenses/>
#
# Retrieved from:
#   svn co https://claire-et-david.dyndns.org/prog/OSCIED

set -o nounset # will exit if an unitialized variable is used

# Constants ========================================================================================

ECHO='juju-log' # Used by logicielsUbuntuUtils

# Charms paths
BASE_PATH=$(pwd)

# Charms files
WEBUI_DB_FILE="$BASE_PATH/webui-db.sql"
SITE_TEMPL_FILE="$BASE_PATH/000-default"

# Shared storage paths
STORAGE_ROOT_PATH='/mnt/storage'
STORAGE_TEMP_PATH="$STORAGE_ROOT_PATH/tmp"
STORAGE_MEDIAS_PATH="$STORAGE_ROOT_PATH/medias"
STORAGE_UPLOADS_PATH="$STORAGE_ROOT_PATH/uploads"

# MySQL configuration files & paths
MYSQL_CONFIG_FILE='/etc/mysql/my.cnf'
MYSQL_TEMP_PATH='/var/lib/mysql/tmp'

# Web user interface paths
WWW_ROOT_PATH='/var/www'
WWW_MEDIAS_PATH="$WWW_ROOT_PATH/medias"
WWW_UPLOADS_PATH="$WWW_ROOT_PATH/uploads"

# Web user interface configuration files
SITES_ENABLED_PATH='/etc/apache2/sites-enabled'
GENERAL_CONFIG_FILE="$WWW_ROOT_PATH/application/config/config.php"
DATABASE_CONFIG_FILE="$WWW_ROOT_PATH/application/config/database.php"
HTACCESS_FILE="$WWW_ROOT_PATH/.htaccess"
ORCHESTRA_FLAG="$WWW_ROOT_PATH/orchestra_relation_ok"

# Configuration ====================================================================================

if [ "$(config-get verbose)" = 'true' ] ; then
  VERBOSE=0     # true
  set -o xtrace # for verbose logging to juju debug-log
else
  VERBOSE=1 # false
fi

PROXY_IPS=$(cat proxy_ips 2>/dev/null)
MAX_UPLOAD_SIZE=$(config-get max_upload_size)
MAX_EXECUTION_TIME=$(config-get max_execution_time)
MAX_INPUT_TIME=$(config-get max_input_time)

API_URL=$(config-get api_url)

STORAGE_IP=$(config-get storage_ip)
STORAGE_NAT_IP=$(config-get storage_nat_ip)
STORAGE_FSTYPE=$(config-get storage_fstype)
STORAGE_MOUNTPOINT=$(config-get storage_mountpoint)
STORAGE_OPTIONS=$(config-get storage_options)

MYSQL_MY_PASS=$(config-get mysql_my_password)
MYSQL_ROOT_PASS=$(config-get mysql_root_password)
MYSQL_USER_PASS=$(config-get mysql_user_password)

# Utilities ========================================================================================

api_config_is_enabled()
{
  [ "$API_URL" ]
}

api_hook_bypass()
{
  if api_config_is_enabled; then
    xecho 'Orchestrator is set in config, api relation is disabled' 1
  fi
}

api_register()
{
  # Overrides api parameters with charm configuration
  if api_config_is_enabled; then # if api options are set
    api_url=$API_URL
  # Or uses api parameters from charm api relation
  elif [ $# -eq 1 ]; then # if function parameters are set
    api_url=$1
  elif [ $# -eq 0 ]; then
    return
  else
    xecho "Usage: $(basename $0).api_register api_url"
  fi

  pecho 'Configure Web UI : Register the Orchestrator'
  setSettingPHP $GENERAL_CONFIG_FILE 'config' 'orchestra_api_url' "$api_url" || xecho 'Config'
  touch "$ORCHESTRA_FLAG" || xecho 'Unable to create flag'
}

api_unregister()
{
  pecho 'Configure Web UI : Unregister the Orchestrator'
  setSettingPHP $GENERAL_CONFIG_FILE 'config' 'orchestra_api_url' '' || xecho 'Config'
  rm -f "$ORCHESTRA_FLAG" 2>/dev/null
}

update_proxies()
{
  if [ $# -ne 2 ]; then
    xecho "Usage: $(basename $0).update_proxies action ip"
  fi
  action=$1
  ip=$2

  PROXY_IPS=$(cat proxy_ips 2>/dev/null)
  case "$action" in
  'add' )
    if ! echo $PROXY_IPS | grep -q "$ip"; then
      [ "$PROXY_IPS" ] && PROXY_IPS="$PROXY_IPS,"
      PROXY_IPS="$PROXY_IPS$ip"
      echo $PROXY_IPS > proxy_ips
      setSettingPHP $GENERAL_CONFIG_FILE 'config' 'proxy_ips' "$PROXY_IPS" || return $false
    fi ;;
  'remove' )
    if echo $PROXY_IPS | grep -q "$ip"; then
      sed -i "s<$ip,<<g;s<,$ip<<g;s<$ip<<g" proxy_ips
      PROXY_IPS=$(cat proxy_ips)
      setSettingPHP $GENERAL_CONFIG_FILE 'config' 'proxy_ips' "$PROXY_IPS" || return $false
    fi ;;
  'cleanup' )
    if "$PROXY_IPS"; then
      PROXY_IPS=''
      echo '' > proxy_ips
      setSettingPHP $GENERAL_CONFIG_FILE 'config' 'proxy_ips' "$PROXY_IPS" || return $false
    fi ;;
  * ) xecho "Unknown action : $action" ;;
  esac

  return $true
}

storage_config_is_enabled()
{
  [ "$STORAGE_IP" -a "$STORAGE_FSTYPE" -a "$STORAGE_MOUNTPOINT" ]
}

storage_is_mounted()
{
  mount | grep -q "$STORAGE_ROOT_PATH"
}

storage_remount()
{
  # Overrides storage parameters with charm configuration
  if storage_config_is_enabled; then # if storage options are set
    ip=$STORAGE_IP
    nat_ip=$STORAGE_NAT_IP
    fstype=$STORAGE_FSTYPE
    mountpoint=$STORAGE_MOUNTPOINT
    options=$STORAGE_OPTIONS
  # Or uses storage parameters from charm storage relation
  elif [ $# -eq 4 ]; then # if function parameters are set
    ip=$1
    nat_ip=''
    fstype=$2
    mountpoint=$3
    options=$4
  elif [ $# -eq 0 ]; then
    return
  else
    xecho "Usage: $(basename $0).storage_remount ip fstype mountpoint options"
  fi

  if [ "$nat_ip" ]; then
    pecho "Update hosts file to map storage internal address $ip to $nat_ip"
    if grep -q "$ip" /etc/hosts; then
      sed -i "s<$nat_ip .*<$nat_ip $ip<" /etc/hosts
    else
      echo "$nat_ip $ip" >> /etc/hosts
    fi
  else
    nat_ip=$ip
  fi

  storage_umount

  r=$STORAGE_ROOT_PATH
  pecho "Mount shared storage [$nat_ip] $ip:$mountpoint type $fstype options '$options' -> $r"
  if [ ! -d "$STORAGE_ROOT_PATH" ]; then
    mkdir "$STORAGE_ROOT_PATH" || xecho "Unable to create shared storage path $STORAGE_ROOT_PATH" 1
  fi

  # FIXME try 5 times, a better way to handle failure
  for i in $(seq 1 5)
  do
    if storage_is_mounted; then
      break
    else
      if [ "$options" ]
      then mount -t "$fstype" -o "$options" "$nat_ip:$mountpoint" "$STORAGE_ROOT_PATH"
      else mount -t "$fstype"               "$nat_ip:$mountpoint" "$STORAGE_ROOT_PATH"
      fi
    fi
    sleep 5
  done

  if storage_is_mounted; then
    storage_migrate_path 'medias'  "$STORAGE_MEDIAS_PATH"  "$WWW_MEDIAS_PATH"  'root'     755 644
    storage_migrate_path 'uploads' "$STORAGE_UPLOADS_PATH" "$WWW_UPLOADS_PATH" 'www-data' 755 644
    # FIXME update /etc/fstab (?)
    pecho 'Configure Web UI : Register shared storage'
    # FIXME this is a little bit cheating with paths ;-)
    storage_uri="$fstype://$ip/$mountpoint"
    uploads_uri="$storage_uri/uploads/"
    medias_uri="$storage_uri/medias/"
    setSettingPHP $GENERAL_CONFIG_FILE 'config' 'uploads_uri' "$uploads_uri" || xecho 'Config' 2
    setSettingPHP $GENERAL_CONFIG_FILE 'config' 'medias_uri'  "$medias_uri"  || xecho 'Config' 3
  else
    xecho 'Unable to mount shared storage' 4
  fi
}

storage_umount()
{
  pecho 'Configure Web UI : Unregister shared storage'
  setSettingPHP $GENERAL_CONFIG_FILE 'config' 'uploads_uri' '' || xecho 'Config' 1
  setSettingPHP $GENERAL_CONFIG_FILE 'config' 'medias_uri'  '' || xecho 'Config' 2

  if storage_is_mounted; then
    # FIXME update /etc/fstab (?)
    pecho 'Unmount shared storage (is actually mounted)'
    umount "$STORAGE_ROOT_PATH" || xecho 'Unable to unmount shared storage' 3
  else
    recho 'Shared storage already unmounted'
  fi
}

storage_hook_bypass()
{
  if storage_config_is_enabled; then
    xecho 'Shared storage is set in config, storage relation is disabled' 1
  fi
}

# Migrate a local Web UI path to shared storage only if necessary ----------------------------------
storage_migrate_path()
{
  if [ $# -ne 6 ]; then
    xecho "Usage: $(basename $0).storage_migrate_path name storage local owner dmod fmod"
  fi

  name=$1
  storage=$2
  local=$3
  owner=$4
  dmod=$5
  fmod=$6

  if [ ! -d "$storage" ]; then
    pecho "Create $name path in storage"
    mkdir -p "$storage" || xecho "Unable to create $name path" 1
  else
    recho "Storage $name path already created"
  fi

  if [ -d "$local" ]; then
    mecho "Migrating files from Web UI $name path to $name path in storage ..."
    rsync -a "$local/" "$storage/" || xecho "Unable to migrate $name files" 2
    rm -rf "$local"
  fi

  if [ ! -h "$local" ]; then
    pecho "Link Web UI $name path to $name path in storage"
    ln -s "$storage" "$local" || xecho "Unable to create $name link" 3
  fi

  pecho "Ensure POSIX rights (owner=$owner:$owner mod=(d=$dmod,f=$fmod)) of $name path in storage"
  chown "$owner:$owner" "$storage" -R || xecho "Unable to chown $storage" 4
  find "$storage" -type d -exec chmod "$dmod" "$storage" \;
  find "$storage" -type f -exec chmod "$fmod" "$storage" \;
}

# HOOKS : Charm Setup ==============================================================================

hook_install()
{
  techo 'Web UI - install'

  # Fix memtest86+ : https://bugs.launchpad.net/ubuntu/+source/grub2/+bug/1069856
  #eval $purge grub-pc grub-common
  #eval $install grub-common grub-pc

  eval $update
  eval $upgrade

  pecho 'Install and configure Network Time Protocol'
  eval $install ntp || xecho 'Unable to install ntp' 1
  eval $service ntp restart || xecho 'Unable to restart ntp service' 2

  techo 'Install and configure MySQL'
  sql='mysql-server mysql-server' # Tip : http://ubuntuforums.org/showthread.php?t=981801
  echo "$sql/root_password select $MYSQL_ROOT_PASS"       | debconf-set-selections
  echo "$sql/root_password_again select $MYSQL_ROOT_PASS" | debconf-set-selections
  mkdir /etc/mysql 2>/dev/null
  eval $install mysql-server glusterfs-client nfs-common || xecho 'Unable to install packages' 3

  # Now MySQL will listen to incoming request of any source
  #sed -i 's/127.0.0.1/0.0.0.0/g' /etc/mysql/my.cnf

  root=$MYSQL_ROOT_PASS

  # Fix ticket #57 : Keystone + MySQL = problems
  mysql -uroot -p"$root" -e "DROP USER ''@'localhost'; DROP USER ''@'$(hostname)';"
  mysql -uroot -p"$root" -e "GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;"
  mysql -uroot -p"$root" -e "SET PASSWORD FOR 'root'@'%' = PASSWORD('$MYSQL_ROOT_PASS');"

  service mysql restart || xecho 'Unable to restart mysql' 4

  pecho 'Import Web User Interface database'
  mysql -u root -p"$MYSQL_ROOT_PASS" < "$WEBUI_DB_FILE" || xecho 'Unable to import database' 5

  pecho 'Create Web User Interface user'
  user='webui'
  pass="$MYSQL_USER_PASS"
  mysql -u root -p"$MYSQL_ROOT_PASS" \
    -e "GRANT ALL ON webui.* TO '$user'@'%' IDENTIFIED BY '$pass';" || \
    xecho 'Unable to create user' 6

  pecho 'Install and configure Apache2 + PHP'
  my='phpmyadmin phpmyadmin' # Tip : http://gercogandia.blogspot.ch/2012/11/automatic-unattended-install-of.html
  echo "$my/app-password password $MYSQL_MY_PASS"         | debconf-set-selections
  echo "$my/app-password-confirm password $MYSQL_MY_PASS" | debconf-set-selections
  echo "$my/mysql/admin-pass password $MYSQL_ROOT_PASS"   | debconf-set-selections
  echo "$my/mysql/app-pass password $MYSQL_ROOT_PASS"     | debconf-set-selections
  echo "$my/reconfigure-webserver multiselect apache2"    | debconf-set-selections
  eval $install apache2 php5 php5-cli php5-curl php5-gd php5-mysql libapache2-mod-auth-mysql \
    phpmyadmin || xecho 'Unable to install packages' 7

  a2enmod rewrite

  pecho 'Copy and configure Web User Interface'
  cp -f "$SITE_TEMPL_FILE" "$SITES_ENABLED_PATH"
  rsync -rtvh --progress --delete --exclude=.svn "www/" "/var/www/"
  key=$(randpass 32 $false $false $false)
  c='Config'
  setSettingBASH $MYSQL_CONFIG_FILE    $true 'tmpdir' "$MYSQL_TEMP_PATH"            || xecho $c 8
  setSettingPHP  $GENERAL_CONFIG_FILE  'config' 'encryption_key'  "$key"            || xecho $c 9
  setSettingPHP  $GENERAL_CONFIG_FILE  'config' 'proxy_ips'       "$PROXY_IPS"      || xecho $c 10
  setSettingPHP  $DATABASE_CONFIG_FILE 'db' 'default' 'hostname' 'localhost'        || xecho $c 11
  setSettingPHP  $DATABASE_CONFIG_FILE 'db' 'default' 'username' 'webui'            || xecho $c 12
  setSettingPHP  $DATABASE_CONFIG_FILE 'db' 'default' 'password' "$MYSQL_USER_PASS" || xecho $c 13
  setSettingPHP  $DATABASE_CONFIG_FILE 'db' 'default' 'database' 'webui'            || xecho $c 14
  mkdir -p                "$MYSQL_TEMP_PATH"
  chown mysql:mysql       "$MYSQL_TEMP_PATH"
  chown www-data:www-data "$WWW_ROOT_PATH" -R

  # config php, mettre short opentags à "on"
  # lire les logs, problème MY_ my_ nom fichier

  pecho 'Expose Apache 2 service'
  open-port 80/tcp

  # FIXME this call is not necessary, but config-changed create an infinite loop, so WE call it
  hook_config_changed
}

hook_uninstall()
{
  techo 'Web UI - uninstall'

  hook_stop
  eval $purge apache2 php5 php5-cli php5-gd php5-mysql libapache2-mod-auth-mysql phpmyadmin \
    apache2.2-common mysql-client-5.5 mysql-client-core-5.5 mysql-common mysql-server \
    mysql-server-5.1 mysql-server-5.5 mysql-server-core-5.5 glusterfs-client nfs-common
  eval $autoremove
  rm -rf /etc/apache2/ /var/www/ /var/log/apache2/ /etc/mysql/ /var/lib/mysql/ /var/log/mysql/
  mkdir /var/www/
}

hook_config_changed()
{
  techo 'Web UI - config changed'

  hook_stop
  pecho 'Configure Web UI : Set limits (upload size, execution time, ...)'
  c='Config'
  upload='upload_max_filesize'
  execution='max_execution_time'
  setSettingPHP $GENERAL_CONFIG_FILE 'config' 'max_upload_size' "$MAX_UPLOAD_SIZE"    || xecho $c 1
  setSettingPHP $GENERAL_CONFIG_FILE 'config' 'uploads_path'    "$WWW_UPLOADS_PATH/"  || xecho $c 2
  setSettingPHP $GENERAL_CONFIG_FILE 'config' 'medias_path'     "$WWW_MEDIAS_PATH/"   || xecho $c 3
  setSettingHTA $HTACCESS_FILE $true "php_value $upload"        "$MAX_UPLOAD_SIZE"    || xecho $c 4
  setSettingHTA $HTACCESS_FILE $true 'php_value post_max_size'  "$MAX_UPLOAD_SIZE"    || xecho $c 5
  setSettingHTA $HTACCESS_FILE $true "php_value $execution"     "$MAX_EXECUTION_TIME" || xecho $c 6
  setSettingHTA $HTACCESS_FILE $true 'php_value max_input_time' "$MAX_INPUT_TIME"     || xecho $c 7
  storage_remount
  api_register
  hook_start
  # FIXME infinite loop is used as config-changed hook !
}

# HOOKS : Charm Service ============================================================================

hook_start()
{
  techo 'Web UI - start'

  if ! storage_is_mounted; then
    recho 'WARNING Do not start Web UI : No shared storage'
  elif [ ! -f "$ORCHESTRA_FLAG" ]; then
    recho 'WARNING Do not start Web UI : No Orchestrator API'
  else
    if ! service mysql status | grep -q 'running'; then
      service mysql start || xecho 'Unable to start MySQL' 1
    fi
    service apache2 start || xecho 'Unable to start Apache 2' 2
  fi
}

hook_stop()
{
  techo 'Web UI - stop'

  service apache2 stop || xecho 'Unable to stop Apache 2' 1
  if service mysql status | grep -q 'running'; then
    service mysql stop || xecho 'Unable to stop MySQL' 2
  fi
}

# HOOKS : Requires API =========================================================================

hook_api_relation_joined()
{
  techo 'Web UI - api relation joined'
  api_hook_bypass
}

hook_api_relation_changed()
{
  techo 'Web UI - api relation changed'
  api_hook_bypass

  # Get configuration from the relation
  ip=$(relation-get private-address)
  api_url=$(relation-get api_url)

  mecho "Orchestrator IP is $ip, API URL is $api_url"
  if [ ! "$ip" -o ! "$api_url" ]; then
    recho 'Waiting for complete setup'
    exit 0
  fi

  hook_stop
  api_register "$api_url"
  hook_start
}

hook_api_relation_broken()
{
  techo 'Web UI - api relation broken'
  api_hook_bypass

  hook_stop
  api_unregister
}

# HOOKS : Requires Storage =========================================================================

hook_storage_relation_joined()
{
  techo 'Web UI - storage relation joined'
  storage_hook_bypass
}

hook_storage_relation_changed()
{
  techo 'Web UI - storage relation changed'
  storage_hook_bypass

  # Get configuration from the relation
  ip=$(relation-get private-address)
  fstype=$(relation-get fstype)
  mountpoint=$(relation-get mountpoint)
  options=$(relation-get options)

  mecho "Storage IP is $ip, fstype: $fstype, mountpoint: $mountpoint, options: $options"
  if [ ! "$ip" -o ! "$fstype" -o ! "$mountpoint" ]; then
    recho 'Waiting for complete setup'
    exit 0
  fi

  hook_stop
  storage_remount "$ip" "$fstype" "$mountpoint" "$options"
  hook_start
}

hook_storage_relation_broken()
{
  techo 'Web UI - storage relation broken'
  storage_hook_bypass

  hook_stop
  storage_umount
}

# HOOKS : Provides Website =========================================================================

hook_website_relation_joined()
{
  techo 'Web UI - website relation joined'

  # Send port & hostname
  relation-set port=80 hostname=$(hostname -f)
}

hook_website_relation_changed()
{
  techo 'Web UI - website relation changed'

  # Get configuration from the relation
  proxy_ip=$(relation-get private-address)

  mecho "Proxy IP is $proxy_ip"
  if [ ! "$proxy_ip" ]; then
    recho 'Waiting for complete setup'
    exit 0
  fi

  hook_stop
  pecho "Configure Web UI : Add $proxy_ip to allowed proxy IPs"
  update_proxies add "$proxy_ip" || xecho 'Unable to add proxy'
  hook_start
}

hook_website_relation_departed()
{
  techo 'Web UI - website relation departed'

  # Get configuration from the relation
  proxy_ip=$(relation-get private-address)

  mecho "Proxy IP is $proxy_ip"
  if [ ! "$proxy_ip" ]; then
    recho 'Waiting for complete setup'
    exit 0
  fi

  hook_stop
  pecho "Configure Web UI : Remove $proxy_ip from allowed proxy IPs"
  update_proxies remove "$proxy_ip" || xecho 'Unable to remove proxy'
  hook_start
}

hook_website_relation_broken()
{
  techo 'Web UI - website relation broken'

  # Get configuration from the relation
  proxy_ip=$(relation-get private-address)

  mecho "Proxy IP is $proxy_ip"
  if [ ! "$proxy_ip" ]; then
    recho 'Waiting for complete setup'
    exit 0
  fi

  hook_stop
  pecho "Configure Web UI : Remove $proxy_ip from allowed proxy IPs"
  update_proxies remove "$proxy_ip" || xecho 'Unable to remove proxy'
  # FIXME does relation broken means that no more proxies are linked to us ? if yes :
  #pecho 'Configure Web UI : Cleanup allowed proxy IPs'
  #update_proxies cleanup || xecho 'Unable to cleanup proxies'
  hook_start
}
