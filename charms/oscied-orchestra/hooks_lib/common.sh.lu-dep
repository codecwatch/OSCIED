#!/usr/bin/env bash

#**************************************************************************************************#
#              OPEN-SOURCE CLOUD INFRASTRUCTURE FOR ENCODING AND DISTRIBUTION : ORCHESTRA
#
#  Authors   : David Fischer
#  Contact   : david.fischer.ch@gmail.com / david.fischer@hesge.ch
#  Project   : OSCIED (OS Cloud Infrastructure for Encoding and Distribution)
#  Copyright : 2012-2013 OSCIED Team. All rights reserved.
#**************************************************************************************************#
#
# This file is part of EBU/UER OSCIED Project.
#
# This project is free software: you can redistribute it and/or modify it under the terms of the
# GNU General Public License as published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This project is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this project.
# If not, see <http://www.gnu.org/licenses/>
#
# Retrieved from https://github.com/EBU-TI/OSCIED

set -o nounset # will exit if an unitialized variable is used

# Constants ========================================================================================

ECHO='juju-log' # Used by logicielsUbuntuUtils
RELEASE=$(lsb_release -cs)
JUJU_CHARMS_SVN='https://claire-et-david.dyndns.org/prog/OSCIED/components'

# Charms paths
BASE_PATH=$(pwd)
LIBRARY_PATH="$BASE_PATH/lib"

# Charms files
CONFIG_FILE="$BASE_PATH/config.json"
CELERY_TEMPL_FILE="$BASE_PATH/templates/celeryconfig.py.template"
CELERY_CONFIG_FILE="$BASE_PATH/celeryconfig.py"
JUJU_TEMPL_FILE="$BASE_PATH/templates/environments.yaml.template"
REPOS_CERTIF_FILE="$BASE_PATH/templates/99a9179b9106d19d4e1cca7a720b079a"

# Shared storage paths
STORAGE_ROOT_PATH='/mnt/storage'
STORAGE_MEDIAS_PATH="$STORAGE_ROOT_PATH/medias"
STORAGE_UPLOADS_PATH="$STORAGE_ROOT_PATH/uploads"

# JuJu, ssh & subversion paths
HOME_PATH='/root'
CHARMS_PATH="$HOME_PATH/charms"
PUBLISHER_PATH="$CHARMS_PATH/$RELEASE/oscied-publisher"
TRANSFORM_PATH="$CHARMS_PATH/$RELEASE/oscied-transform"
WEBUI_PATH="$CHARMS_PATH/$RELEASE/oscied-webui"
JUJU_STORAGE_PATH="$HOME_PATH/.juju/storage"
SVN_CERTIFS_PATH="$HOME_PATH/.subversion/auth/svn.ssl.server"

# JuJu, ssh & subversion files
CERTIF_FILE="$HOME_PATH/.ssh/id_rsa"
JUJU_ENVS_FILE="$HOME_PATH/.juju/environments.yaml"
SVN_SERVERS_FILE='/etc/subversion/servers'

# MongoDB configuration files
MONGO_CONFIG_FILE='/etc/mongodb.conf'

# Configuration ====================================================================================

if [ "$(config-get verbose)" = 'true' ] ; then
  VERBOSE=0     # true
  set -o xtrace # for verbose logging to juju debug-log
else
  VERBOSE=1 # false
fi

OWN_IP=$(unit-get private-address)
API_URL="http://$OWN_IP:5000"
API_LOCAL_URL="http://127.0.0.1:5000"
ROOT_SECRET=$(config-get root_secret)
NODES_SECRET=$(config-get nodes_secret)
REPOS_USER=$(config-get repositories_user)
REPOS_PASS=$(config-get repositories_pass)

WEBUI_REPO=$(config-get webui_repository)
TRANSFORM_REPO=$(config-get transform_repository)
PUBLISHER_REPO=$(config-get publisher_repository)

MONGO_ADMIN_PASSWORD=$(config-get mongo_admin_password)
MONGO_NODES_PASSWORD=$(config-get mongo_nodes_password)
RABBIT_PASSWORD=$(config-get rabbit_password)

STORAGE_IP=$(config-get storage_ip)
STORAGE_NAT_IP=$(config-get storage_nat_ip)
STORAGE_FSTYPE=$(config-get storage_fstype)
STORAGE_MOUNTPOINT=$(config-get storage_mountpoint)
STORAGE_OPTIONS=$(config-get storage_options)

mongo_admin_connection()
{
  if [ $# -ne 1 ]; then
    xecho "Usage: $(basename $0).mongo_admin_connection IP"
  fi
  echo "mongodb://admin:$MONGO_ADMIN_PASSWORD@$1:27017/orchestra"
}

mongo_nodes_connection()
{
  if [ $# -ne 1 ]; then
    xecho "Usage: $(basename $0).mongo_nodes_connection IP"
  fi
  echo "mongodb://nodes:$MONGO_NODES_PASSWORD@$1:27017/celery"
}

rabbit_connection()
{
  if [ $# -ne 1 ]; then
    xecho "Usage: $(basename $0).rabbit_connection IP"
  fi
  echo "amqp://nodes:$RABBIT_PASSWORD@$1:5672/celery"
}

# Utilities ========================================================================================

storage_config_is_enabled()
{
  [ "$STORAGE_IP" -a "$STORAGE_FSTYPE" -a "$STORAGE_MOUNTPOINT" ]
}

storage_is_mounted()
{
  mount | grep -q "$STORAGE_ROOT_PATH"
}

storage_remount()
{
  # Overrides storage parameters with charm configuration
  if storage_config_is_enabled; then # if storage options are set
    ip=$STORAGE_IP
    nat_ip=$STORAGE_NAT_IP
    fstype=$STORAGE_FSTYPE
    mountpoint=$STORAGE_MOUNTPOINT
    options=$STORAGE_OPTIONS
  # Or uses storage parameters from charm storage relation
  elif [ $# -eq 4 ]; then # if function parameters are set
    ip=$1
    nat_ip=''
    fstype=$2
    mountpoint=$3
    options=$4
  elif [ $# -eq 0 ]; then
    return
  else
    xecho "Usage: $(basename $0).storage_remount ip fstype mountpoint options"
  fi

  if [ "$nat_ip" ]; then
    pecho "Update hosts file to map storage internal address $ip to $nat_ip"
    if grep -q "$ip" /etc/hosts; then
      sed -i "s<$nat_ip .*<$nat_ip $ip<" /etc/hosts
    else
      echo "$nat_ip $ip" >> /etc/hosts
    fi
  else
    nat_ip=$ip
  fi

  storage_umount

  r=$STORAGE_ROOT_PATH
  pecho "Mount shared storage [$nat_ip] $ip:$mountpoint type $fstype options '$options' -> $r"
  if [ ! -d "$STORAGE_ROOT_PATH" ]; then
    mkdir "$STORAGE_ROOT_PATH" || xecho "Unable to create shared storage path $STORAGE_ROOT_PATH" 1
  fi

  # FIXME try 5 times, a better way to handle failure
  for i in $(seq 1 5)
  do
    if storage_is_mounted; then
      break
    else
      if [ "$options" ]
      then mount -t "$fstype" -o "$options" "$nat_ip:$mountpoint" "$STORAGE_ROOT_PATH"
      else mount -t "$fstype"               "$nat_ip:$mountpoint" "$STORAGE_ROOT_PATH"
      fi
    fi
    sleep 5
  done

  if storage_is_mounted; then
    # FIXME update /etc/fstab (?)
    pecho 'Configure Orchestra : Register shared storage'
    setSettingJSON_STRING "$CONFIG_FILE" 'storage_ip'         "$ip"         || xecho 'Config' 2
    setSettingJSON_STRING "$CONFIG_FILE" 'storage_fstype'     "$fstype"     || xecho 'Config' 3
    setSettingJSON_STRING "$CONFIG_FILE" 'storage_mountpoint' "$mountpoint" || xecho 'Config' 4
    setSettingJSON_STRING "$CONFIG_FILE" 'storage_options'    "$options"    || xecho 'Config' 5
  else
    xecho 'Unable to mount shared storage' 6
  fi
}

storage_umount()
{
  pecho 'Configure Orchestra : Unregister shared storage'
  setSettingJSON_STRING "$CONFIG_FILE" 'storage_ip'         '' || xecho 'Config' 1
  setSettingJSON_STRING "$CONFIG_FILE" 'storage_fstype'     '' || xecho 'Config' 2
  setSettingJSON_STRING "$CONFIG_FILE" 'storage_mountpoint' '' || xecho 'Config' 3
  setSettingJSON_STRING "$CONFIG_FILE" 'storage_options'    '' || xecho 'Config' 4

  if storage_is_mounted; then
    # FIXME update /etc/fstab (?)
    pecho 'Unmount shared storage (is actually mounted)'
    umount "$STORAGE_ROOT_PATH" || xecho 'Unable to unmount shared storage' 5
    recho 'Shared storage successfully unmounted'
  else
    recho 'Shared storage already unmounted'
  fi
}

storage_hook_bypass()
{
  if storage_config_is_enabled; then
    xecho 'Shared storage is set in config, storage relation is disabled' 1
  fi
}

config_rabbitmq()
{
  pecho 'Configure RabbitMQ Message Broker'
  rabbitmqctl delete_user     guest
  rabbitmqctl delete_vhost    /
  rabbitmqctl add_user        nodes "$RABBIT_PASSWORD"
  rabbitmqctl add_vhost       celery
  rabbitmqctl set_permissions -p celery nodes ".*" ".*" ".*"
  if ! rabbitmqctl list_users | grep -q 'nodes'; then
    xecho 'Unable to add RabbitMQ user' 4
  fi
  if ! rabbitmqctl list_vhosts | grep -q 'celery'; then
    xecho 'Unable to add RabbitMQ vhost' 5
  fi
}

# HOOKS : Charm Setup ==============================================================================

hook_install()
{
  techo 'Orchestrator - install'

  # Fix memtest86+ : https://bugs.launchpad.net/ubuntu/+source/grub2/+bug/1069856
  #eval $purge grub-pc grub-common
  #eval $install grub-common grub-pc

  # I decidec to use the real ffmpeg, not the libav version :
  # http://blog.pkh.me/p/13-the-ffmpeg-libav-situation.html
  # http://doc.ubuntu-fr.org/ffmpeg
  apt-add-repository -y ppa:jon-severinsson/ffmpeg || xecho 'Unable to add FFmpeg repository' 1
  #apt-add-repository -y ppa:juju/pkgs || xecho 'Unable to add JuJu PPA repository' 2
  eval $update
  eval $upgrade

  pecho 'Install and configure Network Time Protocol'
  eval $install ntp || xecho 'Unable to install ntp' 3
  eval $service ntp restart || xecho 'Unable to restart ntp service' 4

  #pecho 'Checkout OSCIED charms locally'
  #eval $install subversion || xecho 'Unable to install packages' 5
  #setSettingBASH "$SVN_SERVERS_FILE" $true 'store-passwords'                    'yes' || exit 6
  #setSettingBASH "$SVN_SERVERS_FILE" $true 'store-plaintext-passwords'          'yes' || exit 7
  #setSettingBASH "$SVN_SERVERS_FILE" $true 'store-ssl-client-cert-pp'           'yes' || exit 8
  #setSettingBASH "$SVN_SERVERS_FILE" $true 'store-ssl-client-cert-pp-plaintext' 'yes' || exit 9
  #mkdir -p "$SVN_CERTIFS_PATH"; cp -f "$REPOS_CERTIF_FILE" "$SVN_CERTIFS_PATH/"
  #checkout "$WEBUI_REPO"     "$WEBUI_PATH"     "$REPOS_USER" "$REPOS_PASS" || exit 10
  #checkout "$TRANSFORM_REPO" "$TRANSFORM_PATH" "$REPOS_USER" "$REPOS_PASS" || exit 11
  #checkout "$PUBLISHER_REPO" "$PUBLISHER_PATH" "$REPOS_USER" "$REPOS_PASS" || exit 12

  pecho 'Install (the real) FFmpeg and x264'
  #pecho 'Install JuJu Cloud Orchestrator, (the real) FFmpeg and x264'
  #eval $install apt-cacher-ng charm-tools juju libzookeeper-java zookeeper ffmpeg x264 || \
  eval $install ffmpeg x264 || xecho 'Unable to install packages' 5

  pecho 'Install python, MongoDB Scalable NoSQL DB, RabbitMQ Message Broker and Gluster Filesystem'
  eval $install build-essential python-dev python python-pip git-core mongodb rabbitmq-server \
    glusterfs-client nfs-common || xecho 'Unable to install packages' 6

  pecho 'Install OSCIED Library'
  python "$LIBRARY_PATH/setup.py" install || xecho 'Unable to install library' 7

  pecho 'Expose RESTful API, MongoDB & RabbitMQ service'
  open-port 5000/tcp   # Orchestra RESTful API
  open-port 27017/tcp  # MongoDB portmongod and mongos instances
  #open-port 27018/tcp # MongoDB port when running with shardsvr setting
  #open-port 27019/tcp # MongoDB port when running with configsvr setting
  open-port 28017/tcp  # MongoDB port for the web status page. This is always +1000
  open-port 5672/tcp   # RabbitMQ service

  # FIXME this call is not necessary, but config-changed create an infinite loop, so WE call it
  hook_config_changed
}

hook_uninstall()
{
  techo 'Orchestrator - uninstall'

  hook_stop

  # fix rabbitmq-server package uninstall error
  mkdir /var/log/rabbitmq 2>/dev/null

  juju destroy-environment
  eval $purge apt-cacher-ng charm-tools juju libzookeeper-java lxc zookeeper
  eval $purge mongodb rabbitmq-server glusterfs-client nfs-common
  pip install uninstall bson flask celery
  eval $autoremove
  rm -rf $HOME/.juju $HOME/.ssh/id_rsa*
  rm -rf /etc/rabbitmq/ /var/log/rabbitmq/
}

hook_config_changed()
{
  techo 'Orchestrator - config changed'

  pecho 'Configure MongoDB Scalable NoSQL DB'

  echo "db.addUser('admin', '$MONGO_ADMIN_PASSWORD', false);" > f.js
  mongo f.js; mongo 'orchestra' f.js
  rm -f f.js

  echo "db.addUser('nodes', '$MONGO_NODES_PASSWORD', false);" > g.js
  mongo 'celery' g.js
  rm -f g.js

  setSettingBASH "$MONGO_CONFIG_FILE" $true 'bind_ip' '0.0.0.0' || xecho 'Config' 1
  setSettingBASH "$MONGO_CONFIG_FILE" $true 'noauth'  'false'   || xecho 'Config' 2
  setSettingBASH "$MONGO_CONFIG_FILE" $true 'auth'    'true'    || xecho 'Config' 3

  config_rabbitmq

  hook_stop

  pecho 'Configure Orchestra the Orchestrator'
  mongo=$(mongo_admin_connection 'localhost')
  rabbit=$(rabbit_connection 'localhost')
  mecho "MongoDB connection is $mongo, RabbitMQ connection is $rabbit"
  if [ ! "$mongo" -o ! "$rabbit" ]; then
    xecho 'Unable to detect MongoDB or RabbitMQ connection' 5
  fi
  setSettingJSON_BOOLEAN "$CONFIG_FILE" 'verbose'           "$VERBOSE"          || xecho 'Config' 6
  setSettingJSON_STRING  "$CONFIG_FILE" 'api_url'           "$API_URL"          || xecho 'Config' 7
  setSettingJSON_STRING  "$CONFIG_FILE" 'root_secret'       "$ROOT_SECRET"      || xecho 'Config' 8
  setSettingJSON_STRING  "$CONFIG_FILE" 'nodes_secret'      "$NODES_SECRET"     || xecho 'Config' 9
  setSettingJSON_STRING  "$CONFIG_FILE" 'mongo_connection'  "$mongo"            || xecho 'Config' 10
  setSettingJSON_STRING  "$CONFIG_FILE" 'rabbit_connection' "$rabbit"           || xecho 'Config' 11
  setSettingJSON_STRING  "$CONFIG_FILE" 'storage_path'     "$STORAGE_ROOT_PATH" || xecho 'Config' 12
  sed "s<RABBIT_CONNECTION<$rabbit<g;s<MONGO_PASSWORD<$MONGO_NODES_PASSWORD<g" \
    < "$CELERY_TEMPL_FILE" > "$CELERY_CONFIG_FILE" || xecho 'Config' 13

  storage_remount

  hook_start
  # FIXME infinite loop is used as config-changed hook !
}

# HOOKS : Charm Service ============================================================================

hook_start()
{
  techo 'Orchestrator - start'

  if ! storage_is_mounted; then
    recho 'WARNING: No shared storage, Orchestra may not start'
  fi

  # do not check status after all, orchestra can do it for us !
  service mongodb         start
  service rabbitmq-server start

  # FIXME this is not a good idea, but I have some trouble with precise release (see ticket #205)
  config_rabbitmq

  if ! curl -s "$API_LOCAL_URL" > /dev/null; then
    screen -dmS 'Orchestra' python orchestra.py
    sleep 5
    if ! curl -s "$API_LOCAL_URL" > /dev/null; then
      # FIXME mail to very important people
      recho 'Orchestra is not ready'
    else
      recho 'Orchestra successfully started'
    fi
  fi
}

hook_stop()
{
  techo 'Orchestrator - stop'

  if curl -s "$API_LOCAL_URL" > /dev/null; then
    screen -X -S 'Orchestra' quit || xecho 'Unable to stop Orchestra daemon' 1
  fi
  service rabbitmq-server stop || xecho 'Unable to stop RabbitMQ' 2
  if ! service mongodb status | grep -q 'stop'; then
    service mongodb stop || xecho 'Unable to stop MongoDB' 3
  fi
}

# HOOKS : Requires Storage =========================================================================

hook_storage_relation_joined()
{
  techo 'Orchestra - storage relation joined'

  storage_hook_bypass
}

hook_storage_relation_changed()
{
  techo 'Orchestra - storage relation changed'

  storage_hook_bypass

  # Get configuration from the relation
  ip=$(relation-get private-address)
  fstype=$(relation-get fstype)
  mountpoint=$(relation-get mountpoint)
  options=$(relation-get options)

  mecho "Storage IP is $ip, fstype: $fstype, mountpoint: $mountpoint, options: $options"
  if [ ! "$ip" -o ! "$fstype" -o ! "$mountpoint" ]; then
    recho 'Waiting for complete setup'
    exit 0
  fi

  hook_stop
  storage_remount "$ip" "$fstype" "$mountpoint" "$options"
  hook_start
}

hook_storage_relation_broken()
{
  techo 'Orchestra - storage relation broken'

  storage_hook_bypass

  hook_stop
  storage_umount
}

# HOOKS : Provides API =============================================================================

hook_api_relation_joined()
{
  techo 'Orchestrator - api relation joined'

  # Send Orchestra API URL
  relation-set "api_url=$API_URL"
}

hook_api_relation_changed()
{
  techo 'Orchestrator - api relation changed'

  # Get configuration from the relation
  webui_ip=$(relation-get private-address)

  mecho "Web UI IP is $webui_ip"
  if [ ! "$webui_ip" ]; then
    recho 'Waiting for complete setup'
    exit 0
  fi

  # FIXME something to do (register unit ?)
}

# HOOKS : Provides Publisher =======================================================================

hook_publisher_relation_joined()
{
  techo 'Orchestrator - publisher relation joined'

  # Send MongoDB & RabbitMQ connections
  mongo=$(mongo_nodes_connection "$OWN_IP")
  rabbit=$(rabbit_connection "$OWN_IP")
  mecho "MongoDB connection is $mongo, RabbitMQ connection is $rabbit"
  if [ ! "$mongo" -o ! "$rabbit" ]; then
    xecho 'Unable to detect MongoDB or RabbitMQ connection'
  fi
  relation-set "mongo_connection=$mongo" "rabbit_connection=$rabbit"
}

hook_publisher_relation_changed()
{
  techo 'Orchestrator - publisher relation changed'

  # Get configuration from the relation
  publisher_ip=$(relation-get private-address)

  mecho "Publisher IP is $publisher_ip"
  if [ ! "$publisher_ip" ]; then
    recho 'Waiting for complete setup'
    exit 0
  fi

  # FIXME something to do (register unit ?)
}

# HOOKS : Provides Transform Relation ==============================================================

hook_transform_relation_joined()
{
  techo 'Orchestrator - transform relation joined'

  # Send MongoDB & RabbitMQ connections
  mongo=$(mongo_nodes_connection "$OWN_IP")
  rabbit=$(rabbit_connection "$OWN_IP")
  mecho "MongoDB connection is $mongo, RabbitMQ connection is $rabbit"
  if [ ! "$mongo" -o ! "$rabbit" ]; then
    xecho 'Unable to detect MongoDB or RabbitMQ connection'
  fi
  relation-set "mongo_connection=$mongo" "rabbit_connection=$rabbit"
}

hook_transform_relation_changed()
{
  techo 'Orchestrator - transform relation changed'

  # Get configuration from the relation
  transform_ip=$(relation-get private-address)

  mecho "Transform IP is $transform_ip"
  if [ ! "$transform_ip" ]; then
    recho 'Waiting for complete setup'
    exit 0
  fi

  # FIXME something to do (register unit ?)
}
