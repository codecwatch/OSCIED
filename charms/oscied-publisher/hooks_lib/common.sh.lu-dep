#!/usr/bin/env bash

#**************************************************************************************************#
#              OPEN-SOURCE CLOUD INFRASTRUCTURE FOR ENCODING AND DISTRIBUTION : PUBLISHER
#
#  Authors   : David Fischer
#  Contact   : david.fischer.ch@gmail.com / david.fischer@hesge.ch
#  Project   : OSCIED (OS Cloud Infrastructure for Encoding and Distribution)
#  Copyright : 2012-2013 OSCIED Team. All rights reserved.
#**************************************************************************************************#
#
# This file is part of EBU/UER OSCIED Project.
#
# This project is free software: you can redistribute it and/or modify it under the terms of the
# GNU General Public License as published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This project is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this project.
# If not, see <http://www.gnu.org/licenses/>
#
# Retrieved from https://github.com/EBU-TI/OSCIED

set -o nounset # will exit if an unitialized variable is used

# Constants ========================================================================================

ECHO='juju-log' # Used by logicielsUbuntuUtils

# Charms paths
BASE_PATH=$(pwd)
LIBRARY_PATH="$BASE_PATH/lib"

# Charms files
CONFIG_FILE="$BASE_PATH/config.json"
CELERY_TEMPL_FILE="$BASE_PATH/templates/celeryconfig.py.template"
CELERY_CONFIG_FILE="$BASE_PATH/celeryconfig.py"

# Shared storage paths
STORAGE_ROOT_PATH='/mnt/storage'
STORAGE_MEDIAS_PATH="$STORAGE_ROOT_PATH/medias"
STORAGE_UPLOADS_PATH="$STORAGE_ROOT_PATH/uploads"

# Apache 2 paths
WWW_ROOT_PATH='/var/www'

# Apache 2 configuration files
HTACCESS_FILE="$WWW_ROOT_PATH/.htaccess"

# Configuration ====================================================================================

if [ "$(config-get verbose)" = 'true' ] ; then
  VERBOSE=0     # true
  set -o xtrace # for verbose logging to juju debug-log
else
  VERBOSE=1 # false
fi

PUBLIC_ADDRESS=$(unit-get public-address)
THE_CONCURRENCY=$(config-get concurrency)
RABBIT_QUEUES="$(config-get rabbit_queues),$PUBLIC_ADDRESS"

PROXY_IPS=$(cat proxy_ips 2>/dev/null)
MAX_UPLOAD_SIZE=$(config-get max_upload_size)
MAX_EXECUTION_TIME=$(config-get max_execution_time)
MAX_INPUT_TIME=$(config-get max_input_time)

MONGO_CONNECTION=$(config-get mongo_connection)
RABBIT_CONNECTION=$(config-get rabbit_connection)
API_NAT_SOCKET=$(config-get api_nat_socket)

STORAGE_IP=$(config-get storage_ip)
STORAGE_NAT_IP=$(config-get storage_nat_ip)
STORAGE_FSTYPE=$(config-get storage_fstype)
STORAGE_MOUNTPOINT=$(config-get storage_mountpoint)
STORAGE_OPTIONS=$(config-get storage_options)

# Utilities ========================================================================================

storage_config_is_enabled()
{
  [ "$STORAGE_IP" -a "$STORAGE_FSTYPE" -a "$STORAGE_MOUNTPOINT" ]
}

storage_is_mounted()
{
  mount | grep -q "$STORAGE_ROOT_PATH"
}

storage_remount()
{
  # Overrides storage parameters with charm configuration
  if storage_config_is_enabled; then # if storage options are set
    ip=$STORAGE_IP
    nat_ip=$STORAGE_NAT_IP
    fstype=$STORAGE_FSTYPE
    mountpoint=$STORAGE_MOUNTPOINT
    options=$STORAGE_OPTIONS
  # Or uses storage parameters from charm storage relation
  elif [ $# -eq 4 ]; then # if function parameters are set
    ip=$1
    nat_ip=''
    fstype=$2
    mountpoint=$3
    options=$4
  elif [ $# -eq 0 ]; then
    return
  else
    xecho "Usage: $(basename $0).storage_remount ip fstype mountpoint options"
  fi

  if [ "$nat_ip" ]; then
    pecho "Update hosts file to map storage internal address $ip to $nat_ip"
    if grep -q "$ip" /etc/hosts; then
      sed -i "s<$nat_ip .*<$nat_ip $ip<" /etc/hosts
    else
      echo "$nat_ip $ip" >> /etc/hosts
    fi
  else
    nat_ip=$ip
  fi

  storage_umount

  r=$STORAGE_ROOT_PATH
  pecho "Mount shared storage [$nat_ip] $ip:$mountpoint type $fstype options '$options' -> $r"
  if [ ! -d "$STORAGE_ROOT_PATH" ]; then
    mkdir "$STORAGE_ROOT_PATH" || xecho "Unable to create shared storage path $STORAGE_ROOT_PATH" 1
  fi

  # FIXME try 5 times, a better way to handle failure
  for i in $(seq 1 5)
  do
    if storage_is_mounted; then
      break
    else
      if [ "$options" ]
      then mount -t "$fstype" -o "$options" "$nat_ip:$mountpoint" "$STORAGE_ROOT_PATH"
      else mount -t "$fstype"               "$nat_ip:$mountpoint" "$STORAGE_ROOT_PATH"
      fi
    fi
    sleep 5
  done

  if storage_is_mounted; then
    # FIXME update /etc/fstab (?)
    pecho 'Configure Publisher : Register shared storage'
    setSettingJSON_STRING "$CONFIG_FILE" 'storage_ip'         "$ip"         || xecho 'Config' 2
    setSettingJSON_STRING "$CONFIG_FILE" 'storage_fstype'     "$fstype"     || xecho 'Config' 3
    setSettingJSON_STRING "$CONFIG_FILE" 'storage_mountpoint' "$mountpoint" || xecho 'Config' 4
    setSettingJSON_STRING "$CONFIG_FILE" 'storage_options'    "$options"    || xecho 'Config' 5
  else
    xecho 'Unable to mount shared storage' 6
  fi
}

storage_umount()
{
  pecho 'Configure Publisher : Unregister shared storage'
  setSettingJSON_STRING "$CONFIG_FILE" 'storage_ip'         '' || xecho 'Config' 1
  setSettingJSON_STRING "$CONFIG_FILE" 'storage_fstype'     '' || xecho 'Config' 2
  setSettingJSON_STRING "$CONFIG_FILE" 'storage_mountpoint' '' || xecho 'Config' 3
  setSettingJSON_STRING "$CONFIG_FILE" 'storage_options'    '' || xecho 'Config' 4

  if storage_is_mounted; then
    # FIXME update /etc/fstab (?)
    pecho 'Unmount shared storage (is actually mounted)'
    umount "$STORAGE_ROOT_PATH" || xecho 'Unable to unmount shared storage' 5
    recho 'Shared storage successfully unmounted'
  else
    recho 'Shared storage already unmounted'
  fi
}

storage_hook_bypass()
{
  if storage_config_is_enabled; then
    xecho 'Shared storage is set in config, storage relation is disabled' 1
  fi
}

publisher_config_is_enabled()
{
  [ "$MONGO_CONNECTION" -a "$RABBIT_CONNECTION" ]
}

publisher_hook_bypass()
{
  if publisher_config_is_enabled; then
    xecho 'Orchestrator is set in config, publisher relation is disabled' 1
  fi
}

publisher_register()
{
  # Overrides publisher parameters with charm configuration
  if publisher_config_is_enabled; then # if publisher options are set
    mongo=$MONGO_CONNECTION
    rabbit=$RABBIT_CONNECTION
    socket=$API_NAT_SOCKET
  # Or uses publisher parameters from charm publisher relation
  elif [ $# -eq 2 ]; then # if function parameters are set
    mongo=$1
    rabbit=$2
    socket=''
  elif [ $# -eq 0 ]; then
    return
  else
    xecho "Usage: $(basename $0).publisher_register mongo rabbit"
  fi

  pecho 'Configure Publisher : Register the Orchestrator'
  setSettingJSON_STRING "$CONFIG_FILE" 'mongo_connection'  "$mongo"  || xecho 'Config' 1
  setSettingJSON_STRING "$CONFIG_FILE" 'rabbit_connection' "$rabbit" || xecho 'Config' 2
  setSettingJSON_STRING "$CONFIG_FILE" 'api_nat_socket'    "$socket" || xecho 'Config' 3

  host=$(expr match "$mongo" '.*mongodb://[^:]*:[^@]*@\([^:]*\):[0-9]*/[a-z]*.*')
  port=$(expr match "$mongo" '.*mongodb://[^:]*:[^@]*@[^:]*:\([0-9]*\)/[a-z]*.*')
  user=$(expr match "$mongo" '.*mongodb://\([^:]*\):[^@]*@[^:]*:[0-9]*/[a-z]*.*')
  password=$(expr match "$mongo" '.*mongodb://[^:]*:\([^@]*\)@[^:]*:[0-9]*/[a-z]*.*')
  database=$(expr match "$mongo" '.*mongodb://[^:]*:[^@]*@[^:]*:[0-9]*/\([a-z]*\).*')
  mecho "MongoDB host=$host, port=$port, user=$user, password=$password, database=$database"
  if [ ! "$host" -o ! "$port" -o ! "$user" -o ! "$password" -o ! "$database" ]; then
    xecho 'Unable to parse MongoDB connection' 3
  fi

  a="s<RABBIT_CONNECTION<$rabbit<g"
  b="s<MONGO_HOST<$host<g"
  c="s<MONGO_PORT<$port<g"
  d="s<MONGO_USER<$user<g"
  e="s<MONGO_PASSWORD<$password<g"
  f="s<MONGO_DATABASE<$database<g"
  g="s<THE_CONCURRENCY<$THE_CONCURRENCY<g"
  sed "$a;$b;$c;$d;$e;$f;$g" "$CELERY_TEMPL_FILE" > "$CELERY_CONFIG_FILE" || xecho 'Config' 4
  recho "Orchestrator successfully registered, it's time to wake-up"
}

publisher_unregister()
{
  pecho 'Configure Publisher : Unregister the Orchestrator'
  setSettingJSON_STRING "$CONFIG_FILE" 'mongodb_connection'  '' || xecho 'Config' 1
  setSettingJSON_STRING "$CONFIG_FILE" 'rabbitmq_connection' '' || xecho 'Config' 2
  setSettingJSON_STRING "$CONFIG_FILE" 'api_nat_socket'      '' || xecho 'Config' 3
  rm -f "$CELERY_CONFIG_FILE"
  recho 'Orchestrator successfully unregistered'
}

# HOOKS : Charm Setup ==============================================================================

hook_install()
{
  techo 'Publisher - install'

  # Remark : You must get dependencies into this charm by executing get-dependencies.sh
  # FIXME share variables with get-dependencies.sh

  eval $update
  eval $upgrade

  pecho 'Install and configure Network Time Protocol'
  eval $install ntp || xecho 'Unable to install ntp' 1
  eval $service ntp restart || xecho 'Unable to restart ntp service' 2

  pecho 'Install python, Apache 2 Web Server and Gluster Filesystem'
  eval $install apache2 apache2-threaded-dev make python python-dev python-pip glusterfs-client \
    nfs-common || xecho 'Unable to install packages' 3
  #rm -rf /var/www/*

  pecho 'Install Apache 2 H.264 streaming module'
  lib='mod_h264_streaming-2.2.7'
  tar="apache_$lib.tar.gz"
  tar -zxvf $tar
  cd $lib || xecho "Unable to find directory $lib" 4
  ./configure --with-apxs=$(which apxs2)
  make && make install || xecho 'Unable to compile module' 5
  cd ..
  rm -rf $lib
  #rm -f $zip

  config='/etc/apache2/apache2.conf'
  module='/usr/lib/apache2/modules/mod_h264_streaming.so'
  if ! grep -q $module $config; then
    echo "LoadModule h264_streaming_module $module"  >> $config
    echo 'AddHandler h264-streaming.extensions .mp4' >> $config
  fi

  pecho 'Install OSCIED Library'
  python "$LIBRARY_PATH/setup.py" install || xecho 'Unable to install library' 6

  pecho 'Expose Apache 2 service'
  open-port 80/tcp

  # FIXME this call is not necessary, but config-changed create an infinite loop, so WE call it
  hook_config_changed
}

hook_uninstall()
{
  techo 'Publisher - uninstall'

  hook_stop
  eval $purge apache2 apache2.2-common glusterfs-client nfs-common
  pip install uninstall bson celery
  eval $autoremove
  rm -rf /etc/apache2/ /var/www/ /var/log/apache2/
  mkdir /var/www/
}

hook_config_changed()
{
  techo 'Publisher - config changed'

  hook_stop
  # FIXME FIXME pecho 'Configure Apache : Set limits (upload size, execution time, ...)'
  #c='Config'
  #upload='upload_max_filesize'
  #execution='max_execution_time'
  #setSettingHTA $HTACCESS_FILE $true "php_value $upload"        "$MAX_UPLOAD_SIZE"    || xecho $c 13
  #setSettingHTA $HTACCESS_FILE $true 'php_value post_max_size'  "$MAX_UPLOAD_SIZE"    || xecho $c 14
  #setSettingHTA $HTACCESS_FILE $true "php_value $execution"     "$MAX_EXECUTION_TIME" || xecho $c 15
  #setSettingHTA $HTACCESS_FILE $true 'php_value max_input_time' "$MAX_INPUT_TIME"     || xecho $c 16

  pecho 'Configure Publisher : Set verbose, messaging queues and storage path'
  setSettingJSON_STRING  "$CONFIG_FILE" 'public_address' "$PUBLIC_ADDRESS"    || xecho 'Config' 1
  setSettingJSON_BOOLEAN "$CONFIG_FILE" 'verbose'        "$VERBOSE"           || xecho 'Config' 2
  setSettingJSON_STRING  "$CONFIG_FILE" 'rabbit_queues'  "$RABBIT_QUEUES"     || xecho 'Config' 3
  setSettingJSON_STRING  "$CONFIG_FILE" 'storage_path'   "$STORAGE_ROOT_PATH" || xecho 'Config' 4
  storage_remount
  publisher_register
  hook_start
  # FIXME infinite loop is used as config-changed hook !
}

# HOOKS : Charm Service ============================================================================

hook_start()
{
  techo 'Publisher - start'

  if ! storage_is_mounted; then
    recho 'WARNING Do not start Publisher daemon : No shared storage'
  elif [ ! -f "$CELERY_CONFIG_FILE" ]; then
    recho 'WARNING Do not start Publisher daemon : No Celery configuration file'
  elif [ ! "$RABBIT_QUEUES" ]; then
    recho 'WARNING Do not start Publisher daemon : No RabbitMQ queue(s) declared'
  else
    service apache2 start || xecho 'Unable to start Apache 2' 1
    if ! screenRunning 'Publisher'; then
      cd "$BASE_PATH" || xecho "Unable to find path $BASE_PATH"
      screenLaunch 'Publisher' celeryd --config 'celeryconfig' -Q "$RABBIT_QUEUES" || \
        xecho 'Unable to start Publisher daemon' 2
    fi
    sleep 5
    if ! screenRunning 'Publisher'; then
      xecho 'Publisher is not ready' 3
    else
      recho 'Publisher successfully started'
    fi
  fi
}

hook_stop()
{
  techo 'Publisher - stop'

  if screenRunning 'Publisher'; then
    screenKill 'Publisher' || xecho 'Unable to stop Publisher daemon' 1
  fi
  service apache2 stop || xecho 'Unable to stop Apache 2' 2
}

# HOOKS : Requires Storage =========================================================================

hook_storage_relation_joined()
{
  techo 'Publisher - storage relation joined'
  storage_hook_bypass
}

hook_storage_relation_changed()
{
  techo 'Publisher - storage relation changed'
  storage_hook_bypass

  # Get configuration from the relation
  ip=$(relation-get private-address)
  fstype=$(relation-get fstype)
  mountpoint=$(relation-get mountpoint)
  options=$(relation-get options)

  mecho "Storage IP is $ip, fstype: $fstype, mountpoint: $mountpoint, options: $options"
  if [ ! "$ip" -o ! "$fstype" -o ! "$mountpoint" ]; then
    recho 'Waiting for complete setup'
    exit 0
  fi

  hook_stop
  storage_remount "$ip" "$fstype" "$mountpoint" "$options"
  hook_start
}

hook_storage_relation_broken()
{
  techo 'Publisher - storage relation broken'
  storage_hook_bypass

  hook_stop
  storage_umount
}

# HOOKS : Requires Publisher =======================================================================

hook_publisher_relation_joined()
{
  techo 'Publisher - publisher relation joined'
  publisher_hook_bypass
}

hook_publisher_relation_changed()
{
  techo 'Publisher - publisher relation changed'
  publisher_hook_bypass

  # Get configuration from the relation
  orchestra_ip=$(relation-get private-address)
  mongo=$(relation-get mongo_connection)
  rabbit=$(relation-get rabbit_connection)
  mecho "Orchestra IP is $orchestra_ip, MongoDB is $mongo, RabbitMQ is $rabbit"
  if [ ! "$orchestra_ip" -o ! "$mongo" -o ! "$rabbit" ]; then
    recho 'Waiting for complete setup'
    exit 0
  fi
  hook_stop
  publisher_register "$mongo" "$rabbit"
  hook_start
}

hook_publisher_relation_broken()
{
  techo 'Publisher - publisher relation broken'
  publisher_hook_bypass

  hook_stop
  publisher_unregister
}

# HOOKS : Provides Website =========================================================================

hook_website_relation_joined()
{
  techo 'Web UI - website relation joined'

  # Send port & hostname
  relation-set port=80 hostname=$(hostname -f)
}
